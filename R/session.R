# Session environment
session <- new.env()

# Active graph
session$graph <- NULL

# Function environment
session$functions <- new.env()

#' Export Function
#'
#' Export a function to the \code{functions} environment in the global session.
#'
#' @param name character scalar, the name to which the function is to be binded in the \code{functions} environment.
#' @param fun function, the function to be exported.
#'
#' @return nothing
#'
#' @author Ron Triepels
#'
#' @name export
#' @keywords internal
export <- function(name, fun)
{
  name <- as.character(name)

  if(!is.function(fun))
  {
    stop("fun is not a valid function")
  }

  if(exists(name, envir = session$functions))
  {
    stop(sprintf("'%s' is already defined", name))
  }

  assign(name, fun, session$functions)
}

#' Generate Name
#'
#' Generate a default name for an expression.
#'
#' @note The auto-generated name is not guaranteed to be unique.
#'
#' @return symbol, auto-generated name for the node.
#'
#' @author Ron Triepels
name <- function()
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$name()
}

#' Add Constant
#'
#' Add a constant node to the active graph.
#'
#' @param value numeric scalar or array, default value of the node.
#' @param name character scalar or symbol, name of the node (optional). In case \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @note Constant nodes are ignored when differentiating a graph.
#'
#' @return cg.node, constant node.
#'
#' @author Ron Triepels
const <- function(value, name)
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$const(value, name)
}

#' Add Input
#'
#' Add an input node to the active graph.
#'
#' @param value numeric scalar or array, default value of the node.
#' @param name character scalar or symbol, name of the node (optional). In case \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @return cg.node, input node.
#'
#' @author Ron Triepels
input <- function(value, name)
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$input(value, name)
}

#' Add Parameter
#'
#' Add a parameter node to the active graph.
#'
#' @param value numeric scalar or array, default value of the node.
#' @param name character scalar or symbol, name of the node (optional). In case \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @return cg.node, parameter node.
#'
#' @author Ron Triepels
parm <- function(value, name)
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$parm(value, name)
}

#' Add Expression
#'
#' Add an expression node to the active graph.
#'
#' @param call expression or call, operations performed by the node.
#' @param grads named list of expressions or calls, gradients of the inputs and parameters used in \code{call} with respect to the node.
#' @param binding named list or environment, binds the values used in the expressions or calls of \code{call} and \code{grads} to the symbols of the nodes in the graph.
#' @param name character scalar or symbol, name of the node (optional). In case \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @note The operation that is to be performed by the node should be provided as an expression or call to argument \code{call}. If this operation contains any inputs or parameters, then the gradient of these inputs and parameters with respect to the node should be provided via argument \code{gradients}. Also, any variables used in the these expressions or calls should be bind to the symbols of the nodes in the graph. There are two ways to bind variables. Either, \code{binding} is a named list were the names of nodes are assigned as symbols to the named members, or \code{binding} is an environment were the names of nodes are assigned as symbols to objects within the environment.
#'
#' @return cg.node, expression node.
#'
#' @author Ron Triepels
expr <- function(call, grads, binding, name)
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$expr(call, grads, binding, name)
}

#' Evaluate a Graph
#'
#' Evaluate node \code{name} in the active graph.
#'
#' @param name character scalar or symbol, name of the node that needs to be evaluated.
#' @param values named list or environment, values that are subsituted for the placeholders in the graph.
#'
#' @note All placeholders required to compute node \code{name} must have a value. Placeholders can be assigned a default value when they are created. Alternatively, argument \code{values} can be used to substitute values for placeholders that do not have a default value or to fix the values of nodes.
#'
#' Only those nodes needed to compute node \code{name} are evaluated and their values are returned. The values of placeholders whose default values are not changed are not returned.
#'
#' @return environment, the value of node \code{name} including the values of all ancestors of node \code{name} that are evaluated in the forward-pass.
#'
#' @author Ron Triepels
run <- function(name, values = list())
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$run(name, values)
}

#' Calculate Gradients
#'
#' Differentiate the active graph with respect to node \code{name} by reverse automatic differentiation.
#'
#' @param name character scalar or symbol, name of the node that needs to be differentiated.
#' @param values named list or environment, values that are subsituted for the expressions and placeholders in the graph.
#' @param index numeric scalar, index of the target node that needs to be differentiated. Defaults to the first element.
#'
#' @note All placeholders and expressions required to compute node \code{name} must have a value. By default, expression nodes are unevaluated. The values of these nodes can be obtained by evaluating the graph using function \code{$run()}. The values obtained by this function for the expression nodes can be supplied along values for the placeholders via argument \code{values}.
#'
#' Currently, cgraph can only differentiate with respect to a scalar output node. In case the value of output node \code{name} is a vector or an array, \code{index} can be used to specify which element of the vector or array needs to be differentiated.
#'
#' The gradients of all parameters are returned along with the gradients of all ancestor nodes of node \code{name} that are calculated in the backward-pass. Constant nodes are not differentiated and their gradients are not returned. Moreover, the gradients of parameters have the same shape as the parameters themselves.
#'
#' @return environment, the gradients of all nodes evaluated in the backward-pass with respect to node \code{name}.
#'
#' @author Ron Triepels
gradients <- function(name, values = list(), index = 1)
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$gradients(name, values, index)
}

#' Approximate Gradients
#'
#' Differentiate node \code{x} with respect to node \code{y} in the active graph by numerical differentiation.
#'
#' @param x character scalar or symbol, name of the node.
#' @param y character scalar or symbol, name of the node.
#' @param values named list or environment, values that are subsituted for the expressions and placeholders in the graph.
#' @param index numeric scalar, index of the target node that needs to be differentiated. Defaults to the first element.
#' @param eps numeric scalar, step size. Defaults to 1e-4.
#'
#' @note All placeholders and expressions required to compute node \code{name} must have a value. By default, expression nodes are unevaluated. The values of these nodes can be obtained by evaluating the graph using function \code{$run()}. The values obtained by this function for the expression nodes can be supplied along values for the placeholders via argument \code{values}.
#'
#' The graph is differentiation by the symmetric difference quotient. This function is mainly used for testing purposes.
#'
#' @return numeric vector or array, the derivative of \code{x} with respect to \code{y}.
#'
#' @author Ron Triepels
approx.grad <- function(x, y, values = list(), index = 1, eps = 1e-4)
{
  if(is.null(session$graph))
  {
    stop("No active graph set")
  }

  session$graph$approx.grad(x, y, values, index, eps)
}
