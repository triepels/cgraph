#' Computational Graph Class Generator
#'
#' Generator class to create new cgraph objects.
#'
#' @details \code{cgraph}
#'
#' @name cgraph
#' @author Ron Triepels
NULL

cgraph <- R6Class(
  classname = "cgraph",
  class = T,
  cloneable = T,
  private = list(
    graph = NULL
  ),
  public = list(
    values = NULL
  )
)

#' Computational Graph
#'
#' Initialize a new computational graph.
#'
#' @details \code{$new()}
#'
#' @note The cgraph object is set to be the active graph. Any nodes that are created by wrapper function \code{const}, \code{input}, or \code{parm} will be added to this graph unless the active graph is changed. You can change the current graph by calling the \code{$active()} method on another cgraph object.
#'
#' @return cgraph object.
#'
#' @name cg.initialize
#' @author Ron Triepels
cgraph$public_methods$initialize <- function()
{
  self$values <- new.env(parent = session$functions)

  private$graph <- .Call("cgraph", new.env(), self$values, PACKAGE = "cgraph")

  self$active()
}

#' Generate Name
#'
#' Generate a default name for a node.
#'
#' @details \code{$name(type = 3)}
#'
#' @param type numeric scalar, type of the node. Should be either: 0 (constant), 1 (input), 2 (parameter), or 3 (operation). Defaults to 3 (operation).
#'
#' @note The auto-generated name is not guaranteed to be unique.
#'
#' @return symbol, auto-generated name for the node.
#'
#' @name cg.name
#' @author Ron Triepels
cgraph$public_methods$name <- function(type = 3)
{
  type <- as.integer(type)

  .Call("cg_gen_name", type, private$graph, PACKAGE = "cgraph")
}

#' Add Constant
#'
#' Add a constant node to the graph.
#'
#' @details \code{$const(value, name)}
#'
#' @param value numeric scalar or array, value of the node.
#' @param name character scalar or symbol, name of the node (optional). In case argument \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @note Constants are ignored when differentiating a graph. The intended use of constants is that they are given a fixed value. However, it is still possible to change the value of constants when evaluating or differentiating a graph (see \link[cgraph]{run} and \link[cgraph]{gradients} for more details).
#'
#' The name of the constant node cannot be 'grad' as this is a reserved word.
#'
#' @return cg.node, constant.
#'
#' @name cg.const
#' @author Ron Triepels
cgraph$public_methods$const <- function(value, name)
{
  type <- as.integer(0)

  if(missing(value))
  {
    value <- NULL
  }
  else
  {
    if(!(is.numeric(value) | is.array(value)))
    {
      stop("value must be a numeric vector or array")
    }
  }

  if(missing(name))
  {
    name <- NULL
  }
  else
  {
    name <- as.character(name)
  }

  .Call("cg_add_placeholder", value, name, type, private$graph, PACKAGE = "cgraph")
}

#' Add Input
#'
#' Add an input node to the graph.
#'
#' @details \code{$input(value, name)}
#'
#' @param value numeric scalar or array, value of the node.
#' @param name character scalar or symbol, name of the node (optional). In case argument \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @note The intended use of inputs is that they are not given a fixed value but behave as placeholders. Values can be supplied for inputs when evaluating or differentiating a graph (see \link[cgraph]{run} and \link[cgraph]{gradients} for more details).
#'
#' The name of the input node cannot be 'grad' as this is a reserved word.
#'
#' @return cg.node, input.
#'
#' @name cg.input
#' @author Ron Triepels
cgraph$public_methods$input <- function(value, name)
{
  type <- as.integer(1)

  if(missing(value))
  {
    value <- NULL
  }
  else
  {
    if(!(is.numeric(value) | is.array(value)))
    {
      stop("value must be a numeric vector or array")
    }
  }

  if(missing(name))
  {
    name <- NULL
  }
  else
  {
    name <- as.character(name)
  }

  .Call("cg_add_placeholder", value, name, type, private$graph, PACKAGE = "cgraph")
}

#' Add Parameter
#'
#' Add a parameter node to the graph.
#'
#' @details \code{$parm(value, name)}
#'
#' @param value numeric scalar or array, value of the node.
#' @param name character scalar or symbol, name of the node (optional). In case \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @note Parameters are assumed to be subject to some optimization process. Their value might change over time.
#'
#' The name of the parameter node cannot be 'grad' as this is a reserved word.
#'
#' @return cg.node, parameter.
#'
#' @name cg.parm
#' @author Ron Triepels
cgraph$public_methods$parm <- function(value, name)
{
  type <- as.integer(2)

  if(missing(value))
  {
    value <- NULL
  }
  else
  {
    if(!(is.numeric(value) | is.array(value)))
    {
      stop("value must be a numeric vector or array")
    }
  }

  if(missing(name))
  {
    name <- NULL
  }
  else
  {
    name <- as.character(name)
  }

  .Call("cg_add_placeholder", value, name, type, private$graph, PACKAGE = "cgraph")
}

#' Get Parameters
#'
#' List all parameters and their values.
#'
#' @details \code{$get.parms()}
#'
#' @return named list, parameters of the graph.
#'
#' @name cg.get.parms
#' @author Ron Triepels
cgraph$public_methods$get.parms <- function()
{
  .Call("cg_get_parms", private$graph);
}

#' Add Parameters
#'
#' Add parameters to the graph.
#'
#' @details \code{$add.parms(..., parms = NULL)}
#'
#' @param ... numeric vectors or arrays, the values of the parameters. Is ignored when \code{parms} is not \code{NULL}.
#' @param parms named list, the parameters that are to be added to the graph.
#'
#' @note Parameters can be named by providing named arguments to \code{...} or by naming the elements of argument \code{parms}. In case no names are provided, parameters are tried to be added to the graph under an auto-generated name. No default value is set for parameters with value \code{NULL}.
#'
#' @return nothing.
#'
#' @name cg.add.parms
#' @author Ron Triepels
cgraph$public_methods$add.parms <- function(..., parms = NULL)
{
  if(is.null(parms))
  {
    parms <- list(...)
  }
  else
  {
    if(!is.list(parms))
    {
      stop("parms must be a list")
    }
  }

  invisible(.Call("cg_add_parms", parms, private$graph))
}

#' Add Operation
#'
#' Add an operation node to the graph.
#'
#' @details \code{$expr(call, grads, binding, name)}
#'
#' @param call expression or call, operations performed by the node.
#' @param grads named list of expressions or calls, gradients of the input nodes that are consumed by the operation in argument \code{call}.
#' @param binding named list or environment, binds the varaibles used in the expressions or calls of argument \code{call} and \code{grads} to the symbols of the nodes in the graph.
#' @param name character scalar or symbol, name of the node (optional). In case argument \code{name} is missing, the node is tried to be added to the graph under an auto-generated name.
#'
#' @note The operation to be performed by the node should be provided as an expression or call to argument \code{call}. If this operation consumes any other nodes in the graph, then the gradients of the current node with respect to these input nodes should be supplied as an expression or call to argument \code{gradients}. These gradients must be a function of each input's gradient. The special reserved word \code{grad} evaluates to this gradient at run-time and can be used in the expression and call of each input's gradient as placeholder.
#'
#' Any variabes used in the expressions or calls of the node (both supplied to argument \code{call} and \code{gradients}) should be bind to the symbols of the nodes in the graph. This can be done by supplying the names of the variables and the corresponding nodes to which the variables should bind to \code{binding}. At run-time, the symbols of the nodes are substituted for the variables in the expressions or calls.
#'
#' The name of the operation node cannot be 'grad' as this is a reserved word.
#'
#' @return cg.node, operation.
#'
#' @name cg.opr
#' @author Ron Triepels
cgraph$public_methods$opr <- function(call, grads, binding, name)
{
  type <- as.integer(3)

  if(!(is.name(call) || is.call(call)))
  {
    call <- as.call(call)
  }

  grads <- as.list(grads)

  if(!is.environment(binding))
  {
    if(!is.list(binding))
    {
      stop("binding must be a named list or environment")
    }

    binding <- list2env(binding)
  }

  if(missing(name))
  {
    name <- NULL
  }
  else
  {
    name <- as.character(name)
  }

  .Call("cg_add_operation", call, grads, binding, name, private$graph, PACKAGE = "cgraph")
}

#' Change Active Graph
#'
#' Set the graph to be the active graph.
#'
#' @details \code{$active()}
#'
#' @note Any placeholders or expressions that are invoked are added to the active graph. This behavior also applies to expressions that are invoked by overloaded S3 functions that do not follow the cg.<name> naming convention (such as primitive functions '+' and '-'). Moreover, only one graph can be active at a time. You can use this function to change the active graph.
#'
#' @return none.
#'
#' @name cg.active
#' @author Ron Triepels
cgraph$public_methods$active <- function()
{
  assign("graph", self, envir = session)
}

#' Evaluate the Graph
#'
#' Evaluate node \code{name} in the graph.
#'
#' @details \code{$run(name, values = list())}
#'
#' @param name character scalar or symbol, name of the node that is evaluated.
#' @param values named list or environment, values that are subsituted for the nodes in the graph.
#'
#' @note All nodes required to compute node \code{name} must have a value or their value must be able to be computed at run-time. Nodes can be assigned a value when they are created. Alternatively, argument \code{values} can be used to substitute values for nodes that do not have a value (e.g. inputs) or to fix their values.
#'
#' Only those nodes needed to compute node \code{name} are evaluated and their values are returned. Values of nodes that have not changed or are not evaluated are not returned.
#'
#' @return environment, the value of node \code{name} including the values of all ancestors of \code{name}.
#'
#' @name cg.run
#' @author Ron Triepels
cgraph$public_methods$run <- function(name, values = list())
{
  name <- as.character(name)

  if(!is.environment(values))
  {
    if(!is.list(values))
    {
      stop("values must be a named list or environment")
    }

    values <- list2env(values)
  }

  .Call("cg_run", name, values, private$graph, PACKAGE = "cgraph")
}

#' Calculate Gradients
#'
#' Differentiate the graph with respect to node \code{name} by reverse automatic differentiation.
#'
#' @details \code{$gradients(name, values, index = 1)}
#'
#' @param name character scalar or symbol, name of the node that is differentiated.
#' @param values named list or environment, values that are subsituted for the nodes in the graph.
#' @param index numeric scalar, index of the target node that is differentiated. Defaults to the first element.
#'
#' @note All nodes required to compute node \code{name} must have a value, or their value must be able to be computed at run-time. The values of nodes can be obtained by first evaluating node \code{name} in the graph using function \code{$run()}. The values obtained by this function for the nodes can then be supplied to argument \code{values}.
#'
#' Currently, the cgraph package can only differentiate scalar target nodes. In case the value of target node \code{name} is a vector or an array, argument \code{index} can be used to specify which element of the vector or array is to be differentiated.
#'
#' The gradients of all ancestor nodes of node \code{name} are returned. Constant nodes are not differentiated and their gradients are not returned. The gradients have the same shape as the values of the nodes.
#'
#' @return environment, the gradients of all nodes with respect to target node \code{name}.
#'
#' @name cg.gradients
#' @author Ron Triepels
cgraph$public_methods$gradients <- function(name, values = list(), index = 1)
{
  name <- as.character(name)

  if(!is.environment(values))
  {
    if(!is.list(values))
    {
      stop("values must be a named list or environment")
    }

    values <- list2env(values)
  }

  index <- as.integer(index)

  .Call("cg_gradients", name, index, values, private$graph, PACKAGE = "cgraph")
}

#' Approximate Gradients
#'
#' Differentiate node \code{x} with respect to node \code{y} by numerical differentiation.
#'
#' @details \code{$approx.grad(x, y, values = list(), index = 1, eps = 1e-4)}
#'
#' @param x character scalar or symbol, name of the node.
#' @param y character scalar or symbol, name of the node.
#' @param values named list or environment, values that are subsituted for the nodes in the graph.
#' @param index numeric scalar, index of the target node that is differentiated. Defaults to the first element.
#' @param eps numeric scalar, step size. Defaults to 1e-4.
#'
#' @note All nodes required to compute node \code{name} must have a value, or their value must be able to be computed at run-time. The values of nodes can be obtained by first evaluating node \code{name} in the graph using function \code{$run()}. The values obtained by this function for the nodes can then be supplied to argument \code{values}.
#'
#' The graph is differentiation by the symmetric difference quotient. This method can only be used to differentiate scalars. In case the value of target node \code{name} is a vector or an array, argument \code{index} can be used to specify which element of the vector or array is differentiated. The caluclated gradient has the same shape as the value of node \code{y}.
#'
#' Numerical differentiation is subject to estimation error and can be very slow. Therefore, this function should only be used for testing purposes.
#'
#' @return numeric vector or array, the derivative of \code{x} with respect to \code{y}.
#'
#' @name cg.approx.grad
#' @author Ron Triepels
cgraph$public_methods$approx.grad <- function(x, y, values = list(), index = 1, eps = 1e-4)
{
  x <- as.character(x)

  y <- as.character(y)

  if(!is.environment(values))
  {
    if(!is.list(values))
    {
      stop("values must be a named list or environment")
    }

    values <- list2env(values)
  }

  index <- as.integer(index)

  eps <- as.numeric(eps)

  .Call("cg_approx_grad", x, y, index, values, eps, private$graph, PACKAGE = "cgraph")
}

#' Adjacency Matrix
#'
#' Retrieve the adjacency matrix of the graph.
#'
#' @details \code{$adj.mat()}
#'
#' @return numeric matrix, the adjacency matrix of the graph.
#'
#' @name cg.adj.mat
#' @author Ron Triepels
cgraph$public_methods$adj.mat <- function()
{
  .Call("cg_adj_mat", private$graph, PACKAGE = "cgraph")
}

#' Plot
#'
#' Plot the topology of the graph.
#'
#' @details \code{$plot(...)}
#'
#' @param ... additional arguments that can be passed on to the plot function of the Rgraphiz package.
#'
#' @note A visual representation of the graph might be usefull for debugging purposes. This functions requires the Rgraphviz package.
#'
#' @return none.
#'
#' @name cg.plot
#' @author Ron Triepels
cgraph$public_methods$plot <- function(...)
{
  Rgraphviz::plot(new("graphAM", adjMat = self$adj.mat(), edgemode = "directed"), ...)
}

#' Plot
#'
#' Plot the topology of a graph.
#'
#' @param x cgraph object, computational graph that is to be plotted.
#' @param ... additional arguments that can be passed on to the plot function of the Rgraphiz package.
#'
#' @note A visual representation of the graph might be usefull for debugging purposes. This functions requires the Rgraphviz package.
#'
#' @return none.
#'
#' @author Ron Triepels
plot.cgraph <- function(x, ...)
{
  x$plot(...)
}
